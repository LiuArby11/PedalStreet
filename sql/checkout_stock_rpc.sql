create table if not exists public.product_variant_stocks (
  id bigint generated by default as identity primary key,
  product_id bigint not null references public.products (id) on delete cascade,
  size text,
  color text,
  stock integer not null default 0 check (stock >= 0),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (product_id, size, color)
);

create or replace function public.set_product_variant_stocks_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_product_variant_stocks_updated_at on public.product_variant_stocks;
create trigger trg_product_variant_stocks_updated_at
before update on public.product_variant_stocks
for each row
execute function public.set_product_variant_stocks_updated_at();

create or replace function public.sync_product_stock_from_variants()
returns trigger
language plpgsql
set search_path = public
as $$
declare
  v_product_id bigint;
begin
  v_product_id := coalesce(new.product_id, old.product_id);

  update public.products p
  set stock = coalesce((
    select sum(v.stock)::integer
    from public.product_variant_stocks v
    where v.product_id = v_product_id
  ), 0)
  where p.id = v_product_id;

  if tg_op = 'UPDATE' and old.product_id is distinct from new.product_id then
    update public.products p
    set stock = coalesce((
      select sum(v.stock)::integer
      from public.product_variant_stocks v
      where v.product_id = old.product_id
    ), 0)
    where p.id = old.product_id;
  end if;

  return null;
end;
$$;

drop trigger if exists trg_sync_product_stock_from_variants on public.product_variant_stocks;
create trigger trg_sync_product_stock_from_variants
after insert or update or delete on public.product_variant_stocks
for each row
execute function public.sync_product_stock_from_variants();

with ranked as (
  select
    id,
    product_id,
    coalesce(size, '') as normalized_size,
    coalesce(color, '') as normalized_color,
    sum(stock) over (
      partition by product_id, coalesce(size, ''), coalesce(color, '')
    ) as merged_stock,
    row_number() over (
      partition by product_id, coalesce(size, ''), coalesce(color, '')
      order by id
    ) as rn
  from public.product_variant_stocks
),
keepers as (
  select id, normalized_size, normalized_color, merged_stock
  from ranked
  where rn = 1
)
update public.product_variant_stocks pvs
set
  size = k.normalized_size,
  color = k.normalized_color,
  stock = k.merged_stock
from keepers k
where pvs.id = k.id;

delete from public.product_variant_stocks pvs
using (
  select id
  from (
    select
      id,
      row_number() over (
        partition by product_id, coalesce(size, ''), coalesce(color, '')
        order by id
      ) as rn
    from public.product_variant_stocks
  ) d
  where d.rn > 1
) dupes
where pvs.id = dupes.id;

update public.product_variant_stocks
set size = ''
where size is null;

update public.product_variant_stocks
set color = ''
where color is null;

alter table public.product_variant_stocks
alter column size set default '';

alter table public.product_variant_stocks
alter column color set default '';

alter table public.product_variant_stocks
alter column size set not null;

alter table public.product_variant_stocks
alter column color set not null;

alter table public.product_variant_stocks enable row level security;

drop policy if exists "Public can read variant stocks" on public.product_variant_stocks;
create policy "Public can read variant stocks"
on public.product_variant_stocks
for select
to anon, authenticated
using (true);

drop policy if exists "Admin can mutate variant stocks" on public.product_variant_stocks;
create policy "Admin can mutate variant stocks"
on public.product_variant_stocks
for all
to authenticated
using (
  exists (
    select 1
    from public.profiles
    where profiles.id = auth.uid()
      and profiles.is_admin = true
  )
)
with check (
  exists (
    select 1
    from public.profiles
    where profiles.id = auth.uid()
      and profiles.is_admin = true
  )
);

create or replace function public.reserve_product_stock(
  p_product_id bigint,
  p_quantity integer,
  p_size text default null,
  p_color text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_stock integer;
  v_name text;
  v_variant_exists boolean;
  v_variant_stock integer;
begin
  if auth.uid() is null then
    return jsonb_build_object('ok', false, 'error', 'Not authenticated.');
  end if;

  if p_quantity is null or p_quantity <= 0 then
    return jsonb_build_object('ok', false, 'error', 'Invalid quantity.');
  end if;

  select stock::integer, name
  into v_stock, v_name
  from public.products
  where id = p_product_id
    and coalesce(is_archived, false) = false
  for update;

  if not found then
    return jsonb_build_object('ok', false, 'error', 'Product not found or archived.');
  end if;

  select exists (
    select 1
    from public.product_variant_stocks
    where product_id = p_product_id
  )
  into v_variant_exists;

  if v_variant_exists then
    select stock::integer
    into v_variant_stock
    from public.product_variant_stocks
    where product_id = p_product_id
      and coalesce(size, '') = coalesce(p_size, '')
      and coalesce(color, '') = coalesce(p_color, '')
    for update;

    if not found then
      return jsonb_build_object('ok', false, 'error', 'Variant not found for selected size/color.');
    end if;

    if v_variant_stock < p_quantity then
      return jsonb_build_object(
        'ok', false,
        'error', format('Insufficient variant stock for %s. Available: %s', coalesce(v_name, 'Product'), v_variant_stock)
      );
    end if;
  end if;

  if v_stock < p_quantity then
    return jsonb_build_object(
      'ok', false,
      'error', format('Insufficient stock for %s. Available: %s', coalesce(v_name, 'Product'), v_stock)
    );
  end if;

  if v_variant_exists then
    update public.product_variant_stocks
    set stock = v_variant_stock - p_quantity
    where product_id = p_product_id
      and coalesce(size, '') = coalesce(p_size, '')
      and coalesce(color, '') = coalesce(p_color, '');
  end if;

  update public.products
  set stock = v_stock - p_quantity
  where id = p_product_id;

  return jsonb_build_object('ok', true, 'remaining_stock', v_stock - p_quantity);
end;
$$;

create or replace function public.release_product_stock(
  p_product_id bigint,
  p_quantity integer,
  p_size text default null,
  p_color text default null
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_stock integer;
  v_variant_exists boolean;
  v_variant_stock integer;
begin
  if auth.uid() is null then
    return jsonb_build_object('ok', false, 'error', 'Not authenticated.');
  end if;

  if p_quantity is null or p_quantity <= 0 then
    return jsonb_build_object('ok', false, 'error', 'Invalid quantity.');
  end if;

  select stock::integer
  into v_stock
  from public.products
  where id = p_product_id
  for update;

  if not found then
    return jsonb_build_object('ok', false, 'error', 'Product not found.');
  end if;

  select exists (
    select 1
    from public.product_variant_stocks
    where product_id = p_product_id
  )
  into v_variant_exists;

  if v_variant_exists then
    select stock::integer
    into v_variant_stock
    from public.product_variant_stocks
    where product_id = p_product_id
      and coalesce(size, '') = coalesce(p_size, '')
      and coalesce(color, '') = coalesce(p_color, '')
    for update;

    if not found then
      return jsonb_build_object('ok', false, 'error', 'Variant not found for selected size/color.');
    end if;

    update public.product_variant_stocks
    set stock = v_variant_stock + p_quantity
    where product_id = p_product_id
      and coalesce(size, '') = coalesce(p_size, '')
      and coalesce(color, '') = coalesce(p_color, '');
  end if;

  update public.products
  set stock = v_stock + p_quantity
  where id = p_product_id;

  return jsonb_build_object('ok', true, 'restored_stock', v_stock + p_quantity);
end;
$$;

create or replace function public.cancel_order_and_restore_stock(
  p_order_id text
)
returns jsonb
language plpgsql
security definer
set search_path = public
as $$
declare
  v_current_status text;
  v_release jsonb;
  v_item record;
begin
  if auth.uid() is null then
    return jsonb_build_object('ok', false, 'error', 'Not authenticated.');
  end if;

  select o.status
  into v_current_status
  from public.orders o
  where o.id::text = p_order_id
  for update;

  if not found then
    return jsonb_build_object('ok', false, 'error', 'Order not found.');
  end if;

  if v_current_status = 'CANCELLED' then
    return jsonb_build_object('ok', true, 'already_cancelled', true);
  end if;

  if v_current_status not in ('PENDING', 'PROCESSING', 'SHIPPED') then
    return jsonb_build_object(
      'ok', false,
      'error', format('Order status %s cannot be cancelled.', coalesce(v_current_status, 'UNKNOWN'))
    );
  end if;

  for v_item in
    select
      oi.product_id,
      oi.quantity,
      oi.selected_size,
      oi.selected_color
    from public.order_items oi
    where oi.order_id::text = p_order_id
  loop
    if v_item.product_id is not null and coalesce(v_item.quantity, 0) > 0 then
      select public.release_product_stock(
        v_item.product_id::bigint,
        v_item.quantity::integer,
        v_item.selected_size,
        v_item.selected_color
      )
      into v_release;

      if coalesce((v_release ->> 'ok')::boolean, false) = false then
        return jsonb_build_object(
          'ok', false,
          'error', coalesce(v_release ->> 'error', 'Stock restore failed.')
        );
      end if;
    end if;
  end loop;

  update public.orders
  set status = 'CANCELLED'
  where id::text = p_order_id;

  return jsonb_build_object('ok', true, 'status', 'CANCELLED');
end;
$$;

revoke all on function public.reserve_product_stock(bigint, integer, text, text) from public;
revoke all on function public.release_product_stock(bigint, integer, text, text) from public;
revoke all on function public.cancel_order_and_restore_stock(text) from public;

grant execute on function public.reserve_product_stock(bigint, integer, text, text) to authenticated;
grant execute on function public.release_product_stock(bigint, integer, text, text) to authenticated;
grant execute on function public.cancel_order_and_restore_stock(text) to authenticated;
